# System Patterns for PreFapMix

## Overall Architecture: Two-Tier Processing

The system employs a two-tier architecture to handle audio processing:

1.  **`workflow_executor.py` (Individual File Processing Tier):**
    *   **Responsibility:** Processes single audio files through a series of configurable stages. It is the workhorse for tasks like stem separation, normalization, diarization, transcription, and per-stream LLM summarization.
    *   **Input:** An individual audio file path and a workflow definition JSON file.
    *   **Output:** A structured run directory containing all intermediate and final outputs for that single audio file. This directory is named using a PII-safe identifier.
    *   **PII Safety:** Generates a `pii_safe_identifier_stem` (e.g., `call_YYYYMMDD-HHMMSS` or `file_YYYYMMDD-HHMMSS`) from the input filename. This stem is then passed as a `pii_safe_file_prefix` to each processing module, ensuring all generated files (temporary and persistent) within that run adhere to PII-safe naming conventions.
    *   **Modularity:** Invokes various specialized Python modules for each stage (e.g., `clap_module.py`, `audio_preprocessor.py`, `diarization_module.py`, `transcription_module.py`, `llm_module.py`).
    *   **Configuration:** Workflow stages, module calls, and input/output mappings between stages are defined in a JSON configuration file (e.g., `default_audio_analysis_workflow.json`).
    *   **Context Passing:** Maintains a workflow context dictionary, passing outputs from one stage as inputs to subsequent stages based on the workflow definition.
    *   **Call Folder Awareness:** If `workflow_executor.py` detects it's processing files within a "call folder" (containing `recv_out` or `trans_out` named files), it will invoke `call_processor.py` as a final step after processing all relevant individual files in that folder.

2.  **`call_processor.py` (Call Aggregation Tier):**
    *   **Responsibility:** Aggregates and combines the outputs from `workflow_executor.py` for paired call recordings (e.g., `recv_out` and `trans_out` streams of the same call).
    *   **Input:** A base directory containing multiple `workflow_executor.py` run directories.
    *   **Output:** A new directory structure for each processed call, containing:
        *   Mixed stereo audio (recv on one channel, trans on the other).
        *   A merged transcript JSON file that combines segments from both streams, maintaining distinct speaker labels (e.g., `RECV_S0`, `TRANS_S1`) and references to the detailed soundbite files generated by `transcription_module.py`.
        *   A combined LLM-generated summary of the entire call.
        *   Copies of the individual stream soundbite structures (folders with `.wav` and `.txt` files per speaker segment) generated by `transcription_module.py`.
    *   **Pair Identification:** Identifies corresponding `recv_out` and `trans_out` run directories based on a generated `call_id` (derived from common timestamp patterns in the original filenames/workflow run directory names).
    *   **File Retrieval:** Uses helper functions to locate specific output files (e.g., normalized vocals, transcript JSONs) within the stage-specific subdirectories of `workflow_executor.py` run directories.

## Key Design Patterns & Principles

*   **Modular Design:** Each core audio processing task (separation, diarization, transcription, etc.) is encapsulated in its own Python module. This promotes separation of concerns, testability, and reusability.
*   **Configuration-Driven Workflow:** The sequence of operations and data flow in `workflow_executor.py` is determined by external JSON configuration files, allowing for flexibility and customization without code changes.
*   **PII-Safe by Design:** PII safety is a core consideration, with a dedicated `pii_safe_file_prefix` propagated throughout the individual file processing stages to ensure all artifacts are named safely.
*   **Idempotency (Goal):** While not fully enforced at all levels yet, operations should ideally be idempotent where possible (e.g., re-running on the same input produces the same output or doesn't cause adverse effects).
*   **Clear Logging:** Comprehensive logging is implemented in all modules to aid in debugging and monitoring workflow execution. Log levels are configurable.
*   **Error Handling:** Modules and workflow stages are designed to handle errors gracefully, log them, and allow the workflow to continue with other files/stages where appropriate (or fail clearly).
*   **Command-Line Interface (CLI):** Both `workflow_executor.py` and `call_processor.py` are designed to be run via CLI, accepting arguments for input/output paths, configurations, and logging levels.
*   **Subprocess Invocation:**
    *   `workflow_executor.py` may call `call_processor.py` as a subprocess.
    *   Modules like `audio_preprocessor.py` may invoke external CLI tools (e.g., `audio-separator`) as subprocesses.
*   **Temporary File Management:** Modules that generate intermediate files (e.g., audio slices for transcription) use temporary directories or clearly named temporary files that are cleaned up after processing.

## Data Flow & Output Structure

*   **`workflow_executor.py` Run Directory Structure (Example):**
    ```
    workspace/workflow_runs/WorkflowName_InputFileStem_Timestamp/
    ├── 00_stage_name/
    │   └── pii_safe_prefix_output_file.ext
    ├── 01_another_stage/
    │   └── pii_safe_prefix_another_file.ext
    ├── ...
    └── WorkflowName_InputFileStem_Timestamp_workflow_summary.json
    └── WorkflowName_InputFileStem_Timestamp_executor.log
    ```
*   **`transcription_module.py` Soundbite Output Structure (within its stage directory):**
    ```
    .../03_transcription/
    ├── pii_safe_prefix_transcription.json  (Main transcript with references)
    ├── S0/                                 (Speaker 0 soundbites)
    │   ├── 0000_first_few_words.wav
    │   ├── 0000_first_few_words.txt
    │   ├── 0001_next_segment_words.wav
    │   ├── 0001_next_segment_words.txt
    │   └── ...
    ├── S1/                                 (Speaker 1 soundbites)
    │   ├── 0000_some_other_words.wav
    │   ├── 0000_some_other_words.txt
    │   └── ...
    └── ...
    ```
*   **`call_processor.py` Output Directory Structure (Example):**
    ```
    workspace/processed_calls/call_YYYYMMDD-HHMMSS/
    ├── call_YYYYMMDD-HHMMSS_mixed_vocals.wav
    ├── call_YYYYMMDD-HHMMSS_merged_transcript.json
    ├── call_YYYYMMDD-HHMMSS_combined_call_summary.txt
    ├── RECV_S0/ (Copied/linked from recv workflow output)
    │   ├── ... (soundbites)
    ├── RECV_S1/
    │   ├── ...
    ├── TRANS_S0/ (Copied/linked from trans workflow output)
    │   ├── ...
    ├── TRANS_S1/
    │   ├── ...
    └── ... (copied individual stream summaries, etc.)
    ```

## Important Considerations

*   **Dependency Management:** Python dependencies need to be managed (e.g., via `requirements.txt`). External CLI tool dependencies (like `ffmpeg`) must be installed on the system.
*   **Resource Usage:** Some stages (like stem separation and transcription) can be resource-intensive (CPU, GPU, RAM).
*   **Model Management:** Pretrained models for diarization, transcription, and separation need to be accessible (downloaded/cached).